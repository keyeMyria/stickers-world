# create container image
docker build -t stickers-world:v3 .
# run container
sudo docker run -p 3000:3000 -t stickers-world:v3

#setup
sudo snap install docker --classic
sudo snap install minikube --classic
sudo snap install kubectl --classic
kubectl config use-context minikube
eval $(minikube docker-env)

# run
minikube start
kubectl run stickers-world --image=stickers-world:v3 --port=3000
kubectl get deployments
kubectl expose deployment stickers-world --type=LoadBalancer
kubectl get services
minikube service stickers-world
# update
kubectl set image deployment/hello-node hello-node=hello-node:v2
# clean up
kubectl delete service hello-node
kubectl delete deployment hello-node
minikube stop

kubectl create -f kubeconfig/config.yaml --save-config
kubectl delete -f kubeconfig/config.yaml
kubectl apply -f kubeconfig/config.yaml

kubectl get pods
kubectl exec -it node-1472368165-cs9p3 -- /bin/bash

minikube start
eval $(minikube docker-env)
minikube mount ./stickers-world-backend /stickers-world-backend-dev


# Development workflow

For development workflow app container doesn't include its source code, instead of this 
it mounts directory from host machine.

1) Start

# Switch context
kubectl config use-context minikube
# Start minikube (minikube docker-env?)
minikube start
eval $(minikube docker-env)
# Mount app's directory to the minikube virtual machine
minikube mount ./stickers-world-backend /stickers-world-backend-dev &

2) Create

# Build development docker image
docker build -f Dockerfile.dev -t stickers-world-dev:latest .
# Add kubernetes dev config
kubectl create -f kubernetes-config/dev/ --save-config

3) Force pull new latest image
kubectl delete pods -l='app==node'

4) Get app url
minikube service node --url

